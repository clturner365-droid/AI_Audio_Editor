#!/usr/bin/env python3
"""
modules/text_html_export.py

Generates:
  - Plain text transcript file
  - Modern HTML transcript file with:
        * backgroundspeaker.jpg background
        * optional speaker photo
        * scripture auto-linking
        * cleanup-friendly speaker placeholder
        * hidden copyright header

Design:
  - Speaker photo directory is passed from main via ctx["speaker_photo_dir"]
  - Speaker photo filename = canonical_name with spaces replaced by underscores
  - HTML and TXT always written, even if speaker unknown
"""

import os
import re
from pathlib import Path
from datetime import datetime
from modules.logging_system import append_file_log


# ---------------------------------------------------------
# CONSTANTS
# ---------------------------------------------------------

UNKNOWN_SPEAKER_PLACEHOLDER = "UNKNOWN_SPEAKER"

# Bible book mapping for filename generation
BOOK_MAP = {
    # Old Testament
    "Genesis": "gen",
    "Exodus": "exo",
    "Leviticus": "lev",
    "Numbers": "num",
    "Deuteronomy": "deu",
    "Joshua": "jos",
    "Judges": "jdg",
    "Ruth": "rut",
    "1 Samuel": "1sa",
    "2 Samuel": "2sa",
    "1 Kings": "1ki",
    "2 Kings": "2ki",
    "1 Chronicles": "1ch",
    "2 Chronicles": "2ch",
    "Ezra": "ezr",
    "Nehemiah": "neh",
    "Esther": "est",
    "Job": "job",
    "Psalms": "psa",
    "Proverbs": "pro",
    "Ecclesiastes": "ecc",
    "Song of Solomon": "sos",
    "Isaiah": "isa",
    "Jeremiah": "jer",
    "Lamentations": "lam",
    "Ezekiel": "eze",
    "Daniel": "dan",
    "Hosea": "hos",
    "Joel": "joe",
    "Amos": "amo",
    "Obadiah": "oba",
    "Jonah": "jon",
    "Micah": "mic",
    "Nahum": "nah",
    "Habakkuk": "hab",
    "Zephaniah": "zep",
    "Haggai": "hag",
    "Zechariah": "zec",
    "Malachi": "mal",

    # New Testament
    "Matthew": "mat",
    "Mark": "mrk",
    "Luke": "luk",
    "John": "john",
    "Acts": "acts",
    "Romans": "rom",
    "1 Corinthians": "1cor",
    "2 Corinthians": "2cor",
    "Galatians": "gal",
    "Ephesians": "eph",
    "Philippians": "php",
    "Colossians": "col",
    "1 Thessalonians": "1th",
    "2 Thessalonians": "2th",
    "1 Timothy": "1ti",
    "2 Timothy": "2ti",
    "Titus": "tit",
    "Philemon": "phm",
    "Hebrews": "heb",
    "James": "jam",
    "1 Peter": "1pe",
    "2 Peter": "2pe",
    "1 John": "1jo",
    "2 John": "2jo",
    "3 John": "3jo",
    "Jude": "jud",
    "Revelation": "rev",
}


# ---------------------------------------------------------
# HELPERS
# ---------------------------------------------------------

def _split_into_paragraphs(text: str):
    if not text:
        return []
    parts = [p.strip() for p in text.split("\n\n")]
    return [p for p in parts if p]


def _safe_speaker_name(state):
    speaker = state.get("speaker_name") or state.get("fingerprint", {}).get("speaker")
    return speaker if speaker else UNKNOWN_SPEAKER_PLACEHOLDER


def _find_speaker_photo(speaker, photo_dir):
    """
    speaker: canonical name
    photo_dir: directory passed from main
    """
    if not speaker or speaker == UNKNOWN_SPEAKER_PLACEHOLDER:
        return None

    filename = speaker.replace(" ", "_")
    for ext in (".jpg", ".jpeg", ".png"):
        candidate = Path(photo_dir) / f"{filename}{ext}"
        if candidate.exists():
            return candidate.name  # relative path for HTML

    return None


def _link_scriptures(paragraph: str):
    """
    Converts scripture references into internal links.
    Example: Acts 1:1 â†’ <a href="kjv_acts001.htm#1">Acts 1:1</a>
    """

    # Regex for scripture references
    pattern = r"\b((?:[1-3]\s)?[A-Z][a-z]+(?:\s(?:of|the)\s[A-Z][a-z]+)?(?:\s[1-3])?)\s+(\d+):(\d+)\b"

    def repl(match):
        book = match.group(1).strip()
        chapter = int(match.group(2))
        verse = int(match.group(3))

        if book not in BOOK_MAP:
            return match.group(0)

        book_code = BOOK_MAP[book]
        chapter_str = f"{chapter:03d}"
        link = f"kjv_{book_code}{chapter_str}.htm#{verse}"

        return f'<a href="{link}">{match.group(0)}</a>'

    return re.sub(pattern, repl, paragraph)


def _write_text_file(path, title, speaker, paragraphs, log_buffer):
    try:
        with open(path, "w", encoding="utf-8") as f:
            f.write(f"{title}\n")
            f.write(f"Speaker: {speaker}\n\n")
            for p in paragraphs:
                f.write(p + "\n\n")
        append_file_log(log_buffer, f"text_html_export: wrote TXT {path}")
    except Exception as e:
        append_file_log(log_buffer, f"text_html_export: failed to write TXT: {e}")


def _write_html_file(path, title, speaker, speaker_photo, paragraphs, log_buffer):
    year = datetime.now().year

    html = [
        f"<!-- auto generated by AI audio processor copyright {year} -->",
        "<!DOCTYPE html>",
        "<html lang='en'>",
        "<head>",
        "<meta charset='UTF-8'>",
        f"<title>{title}</title>",
        "<style>",
        "body {",
        "    margin: 0;",
        "    padding: 0;",
        "    background: url('backgroundspeaker.jpg') no-repeat center center fixed;",
        "    background-size: cover;",
        "    font-family: Georgia, serif;",
        "}",
        ".content-card {",
        "    background: rgba(255, 255, 255, 0.92);",
        "    max-width: 900px;",
        "    margin: 3rem auto;",
        "    padding: 2.5rem;",
        "    border-radius: 12px;",
        "    box-shadow: 0 4px 20px rgba(0,0,0,0.25);",
        "}",
        "h1 { text-align: center; font-size: 2.2rem; margin-top: 0; }",
        "h2 { text-align: center; color: #444; font-weight: 600; margin-top: 0.5rem; }",
        "p { margin: 1.2rem 0; font-size: 1.15rem; line-height: 1.7; color: #222; }",
        ".speaker-photo {",
        "    display: block;",
        "    margin: 0 auto 1rem auto;",
        "    width: 180px;",
        "    border-radius: 8px;",
        "    box-shadow: 0 2px 6px rgba(0,0,0,0.2);",
        "}",
        "</style>",
        "</head>",
        "<body>",
        "<div class='content-card'>",
        f"<h1>{title}</h1>",
    ]

    if speaker_photo:
        html.append(f"<img src='{speaker_photo}' alt='{speaker}' class='speaker-photo'>")

    html.append(f"<h2>{speaker}</h2>")

    for p in paragraphs:
        html.append(f"<p>{_link_scriptures(p)}</p>")

    html.extend([
        "</div>",
        "</body>",
        "</html>"
    ])

    try:
        with open(path, "w", encoding="utf-8") as f:
            f.write("\n".join(html))
        append_file_log(log_buffer, f"text_html_export: wrote HTML {path}")
    except Exception as e:
        append_file_log(log_buffer, f"text_html_export: failed to write HTML: {e}")


# ---------------------------------------------------------
# DISPATCHER ENTRY POINT
# ---------------------------------------------------------

def run(state, ctx):
    """
    Dispatcher-compatible entry point.
    Creates TXT and HTML transcript exports.
    """

    log_buffer = ctx["log_buffer"]
    out_dir = Path(state["out_dir"])
    base = state["base"]

    title = state.get("sermon_title", "Untitled Sermon")
    transcript = state.get("transcript", {}).get("full_text", "")
    speaker = _safe_speaker_name(state)

    paragraphs = _split_into_paragraphs(transcript)

    # Speaker photo directory passed from main
    photo_dir = ctx.get("speaker_photo_dir", "")
    speaker_photo = _find_speaker_photo(speaker, photo_dir)

    txt_path = str(out_dir / f"{base}.txt")
    html_path = str(out_dir / f"{base}.html")

    _write_text_file(txt_path, title, speaker, paragraphs, log_buffer)
    _write_html_file(html_path, title, speaker, speaker_photo, paragraphs, log_buffer)

    final_paths = state.setdefault("final_paths", {})
    final_paths["text"] = txt_path
    final_paths["html"] = html_path

    append_file_log(log_buffer, "text_html_export: completed")

    return state
